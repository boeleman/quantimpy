

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>quantimpy.minkowski module &#8212; QuantImPy 0.4.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bizstyle.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="quantimpy.morphology module" href="quantimpy.morphology.html" />
    <link rel="prev" title="quantimpy.brisque module" href="quantimpy.brisque.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quantimpy.morphology.html" title="quantimpy.morphology module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="quantimpy.brisque.html" title="quantimpy.brisque module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuantImPy 0.4.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="quantimpy.html" accesskey="U">quantimpy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quantimpy.minkowski module</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-quantimpy.minkowski">
<span id="quantimpy-minkowski-module"></span><h1>quantimpy.minkowski module<a class="headerlink" href="#module-quantimpy.minkowski" title="Permalink to this headline">¶</a></h1>
<p>Compute the Minkowski functionals and functions</p>
<p>This module can compute both the Minkowski functionals and functions for 2D and
3D Numpy <a class="footnote-reference brackets" href="#id10" id="id1">1</a> arrays. These computations can handle both isotropic and anisotropic
image resolutions.</p>
<p class="rubric">Notes</p>
<p>More information about the used algorithm can be found in the book “Statistical
analysis of microstructures in materials science” by Joachim Ohser and Frank
Mücklich <a class="footnote-reference brackets" href="#id11" id="id2">2</a>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="quantimpy.minkowski.functionals">
<span class="sig-prename descclassname"><span class="pre">quantimpy.minkowski.</span></span><span class="sig-name descname"><span class="pre">functionals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quantimpy.minkowski.functionals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Minkowski functionals in 2D or 3D.</p>
<p>This function computes the Minkowski functionals for the Numpy array <cite>image</cite>. Both
2D and 3D arrays are supported. Optionally, the (anisotropic) resolution of the
array can be provided using the Numpy array <cite>res</cite>. When a resolution array is
provided it needs to be of the same dimension as the image array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>ndarray</em><em>, </em><em>bool</em>) – Image can be either a 2D or 3D array of data type <cite>bool</cite>.</p></li>
<li><p><strong>res</strong> (<em>ndarray</em><em>, </em><em>{int</em><em>, </em><em>float}</em><em>, </em><em>optional</em>) – By default the resolution is assumed to be 1 &lt;unit of length&gt;/pixel in all directions.
If a resolution is provided it needs to be of the same dimension as the
image array.</p></li>
<li><p><strong>norm</strong> (<em>bool</em><em>, </em><em>defaults to False</em>) – When norm=True the functionals are normalized with the total area or
volume of the image. Defaults to norm=False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – In the case of a 2D image this function returns a tuple of the area,
length, and the Euler characteristic. In the case of a 3D image this
function returns a tuple of the volume, surface, curvature, and the
Euler characteristic. The return data type is <cite>float</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple, float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#quantimpy.minkowski.functions_open" title="quantimpy.minkowski.functions_open"><code class="xref py py-obj docutils literal notranslate"><span class="pre">functions_open</span></code></a>, <a class="reference internal" href="#quantimpy.minkowski.functions_close" title="quantimpy.minkowski.functions_close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">functions_close</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The definition of the Minkowski functionals follows the convention in the
physics literature <a class="footnote-reference brackets" href="#id12" id="id3">3</a>.</p>
<p>Considering a 2D body, <span class="math notranslate nohighlight">\(X\)</span>, with a smooth boundary, <span class="math notranslate nohighlight">\(\delta X\)</span>,
the following functionals are computed:</p>
<div class="math notranslate nohighlight">
\[\begin{split}M_{0} (X) &amp;= \int_{X} d s, \\
M_{1} (X) &amp;= \frac{1}{2 \pi} \int_{\delta X} d c, \text{ and } \\
M_{2} (X) &amp;= \frac{1}{2 \pi^{2}} \int_{\delta X} \left[\frac{1}{R} \right] d c,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(d s\)</span> is a surface element and <span class="math notranslate nohighlight">\(d c\)</span> is a circumference
element. <span class="math notranslate nohighlight">\(R\)</span> is the radius of the local curvature. This results in the
following definitions for the surface area, <span class="math notranslate nohighlight">\(S = M_{0} (X)\)</span>,
circumference, <span class="math notranslate nohighlight">\(C = 2 \pi M_{1} (X)\)</span>, and the 2D Euler characteristic,
<span class="math notranslate nohighlight">\(\chi (X) = \pi M_{2} (X)\)</span>.</p>
<p>Considering a 3D body, <span class="math notranslate nohighlight">\(X\)</span>, with a smooth boundary surface, <span class="math notranslate nohighlight">\(\delta
X\)</span>, the following functionals are computed:</p>
<div class="math notranslate nohighlight">
\[\begin{split}M_{0} (X) &amp;= V = \int_{X} d v, \\
M_{1} (X) &amp;= \frac{1}{8} \int_{\delta X} d s, \\
M_{2} (X) &amp;= \frac{1}{2 \pi^{2}} \int_{\delta X}  \frac{1}{2} \left[\frac{1}{R_{1}} + \frac{1}{R_{2}}\right] d s, \text{ and } \\
M_{3} (X) &amp;= \frac{3}{(4 \pi)^{2}} \int_{\delta X} \left[\frac{1}{R_{1} R_{2}}\right] d s,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(d v\)</span> is a volume element and <span class="math notranslate nohighlight">\(d s\)</span> is a surface element.
<span class="math notranslate nohighlight">\(R_{1}\)</span> and <span class="math notranslate nohighlight">\(R_{2}\)</span> are the principal radii of curvature of
surface element <span class="math notranslate nohighlight">\(d s\)</span>. This results in the following definitions for
the volume, <span class="math notranslate nohighlight">\(V = M_{0} (X)\)</span>, surface area, <span class="math notranslate nohighlight">\(S = 8 M_{1} (X)\)</span>,
integral mean curvature, <span class="math notranslate nohighlight">\(H = 2 \pi^{2} M_{2} (X)\)</span>, and the 3D Euler
characteristic, <span class="math notranslate nohighlight">\(\chi (X) = 4 \pi/3 M_{3} (X)\)</span>.</p>
<p class="rubric">Examples</p>
<p>These examples use the scikit-image Python package <a class="footnote-reference brackets" href="#id14" id="id4">4</a> and the Matplotlib Python
package <a class="footnote-reference brackets" href="#id15" id="id5">5</a>. For a 2D image the Minkowski functionals can be computed using
the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="p">(</span><span class="n">disk</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">minkowski</span> <span class="k">as</span> <span class="n">mk</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">image</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">,</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">minkowski</span> <span class="o">=</span> <span class="n">mk</span><span class="o">.</span><span class="n">functionals</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">minkowski</span><span class="p">)</span>

<span class="c1"># Compute Minkowski functionals for image with anisotropic resolution</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">minkowski</span> <span class="o">=</span> <span class="n">mk</span><span class="o">.</span><span class="n">functionals</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">res</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">minkowski</span><span class="p">)</span>
</pre></div>
</div>
<p>For a 3D image the Minkowski functionals can be computed using the following
example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ball</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">minkowski</span> <span class="k">as</span> <span class="n">mk</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">image</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">,</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">,</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span> <span class="n">ball</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:,</span><span class="mi">64</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">minkowski</span> <span class="o">=</span> <span class="n">mk</span><span class="o">.</span><span class="n">functionals</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">minkowski</span><span class="p">)</span>

<span class="c1"># Compute Minkowski functionals for image with anisotropic resolution</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">minkowski</span> <span class="o">=</span> <span class="n">mk</span><span class="o">.</span><span class="n">functionals</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">res</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">minkowski</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quantimpy.minkowski.functions_close">
<span class="sig-prename descclassname"><span class="pre">quantimpy.minkowski.</span></span><span class="sig-name descname"><span class="pre">functions_close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">closing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quantimpy.minkowski.functions_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Minkowski functions in 2D or 3D.</p>
<p>This function computes the Minkowski functionals as function of the
grayscale values in the Numpy array <cite>closing</cite>. Both 2D and 3D arrays are supported.
Optionally, the (anisotropic) resolution of the array can be provided using
the Numpy array <cite>res</cite>. When a resolution array is provided it needs to be of
the same dimension as the ‘closing’ array.</p>
<p>The algorithm iterates over all grayscale values present in the array,
starting at the largest value (white). For every grayscale value the array
is converted into a binary image where values larger than the grayscale
value become one (white) and all other values become zero (black). For each
of these binary images the minkowski functionals are computed according to
the function <a class="reference internal" href="#quantimpy.minkowski.functionals" title="quantimpy.minkowski.functionals"><code class="xref py py-func docutils literal notranslate"><span class="pre">functionals()</span></code></a>.</p>
<p>This function can be used in combination with the
<a class="reference internal" href="quantimpy.morphology.html#module-quantimpy.morphology" title="quantimpy.morphology"><code class="xref py py-func docutils literal notranslate"><span class="pre">morphology()</span></code></a> module to compute the Minkowski functions of
different morphological distance maps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>closing</strong> (<em>ndarray</em><em>, </em><em>float</em>) – Closing can be either a 2D or 3D array of data type <cite>float</cite>.</p></li>
<li><p><strong>res</strong> (<em>ndarray</em><em>, </em><em>{int</em><em>, </em><em>float}</em><em>, </em><em>optional</em>) – By default the resolution is assumed to be 1 &lt;unit of length&gt;/pixel in all directions.
If a resolution is provided it needs to be of the same dimension as the
image array.</p></li>
<li><p><strong>norm</strong> (<em>bool</em><em>, </em><em>defaults to False</em>) – When norm=True the functions are normalized with the total area or
volume of the image. Defaults to norm=False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – In the case of a 2D image this function returns a tuple of Numpy arrays
consisting of the distance (assuming one grayscale value is used per
unit of length), area, length, and the Euler characteristic. In the
case of a 3D image this function returns a tuple of Numpy arrays
consistenting of the distance, volume, surface, curvature, and the Euler
characteristic. The return data type is <cite>float</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple, ndarray, float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#quantimpy.minkowski.functionals" title="quantimpy.minkowski.functionals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">functionals</span></code></a>, <a class="reference internal" href="#quantimpy.minkowski.functions_open" title="quantimpy.minkowski.functions_open"><code class="xref py py-obj docutils literal notranslate"><span class="pre">functions_open</span></code></a>, <a class="reference internal" href="quantimpy.morphology.html#module-quantimpy.morphology" title="quantimpy.morphology"><code class="xref py py-obj docutils literal notranslate"><span class="pre">morphology</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>These examples use the scikit-image Python package <a class="footnote-reference brackets" href="#id14" id="id6">4</a> and the Matplotlib Python
package <a class="footnote-reference brackets" href="#id15" id="id7">5</a>. For a 2D image the Minkowski functions can be computed using
the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="p">(</span><span class="n">disk</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">morphology</span> <span class="k">as</span> <span class="n">mp</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">minkowski</span> <span class="k">as</span> <span class="n">mk</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">image</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">,</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

<span class="n">erosion_map</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">erode_map</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">erosion_map</span><span class="p">[:,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">dist</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">euler</span> <span class="o">=</span> <span class="n">mk</span><span class="o">.</span><span class="n">functions_close</span><span class="p">(</span><span class="n">erosion_map</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">area</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">length</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">euler</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>For a 3D image the Minkowski functionals can be computed using the following
example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ball</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">morphology</span> <span class="k">as</span> <span class="n">mp</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">minkowski</span> <span class="k">as</span> <span class="n">mk</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">image</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">,</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">,</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span> <span class="n">ball</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

<span class="n">erosion_map</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">erode_map</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:,</span><span class="mi">64</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">erosion_map</span><span class="p">[:,:,</span><span class="mi">64</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">dist</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">curvature</span><span class="p">,</span> <span class="n">euler</span> <span class="o">=</span> <span class="n">mk</span><span class="o">.</span><span class="n">functions_close</span><span class="p">(</span><span class="n">erosion_map</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">volume</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">surface</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">curvature</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">euler</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quantimpy.minkowski.functions_open">
<span class="sig-prename descclassname"><span class="pre">quantimpy.minkowski.</span></span><span class="sig-name descname"><span class="pre">functions_open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opening</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">res</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quantimpy.minkowski.functions_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Minkowski functions in 2D or 3D.</p>
<p>This function computes the Minkowski functionals as function of the
grayscale values in the Numpy array <cite>opening</cite>. Both 2D and 3D arrays are supported.
Optionally, the (anisotropic) resolution of the array can be provided using
the Numpy array <cite>res</cite>. When a resolution array is provided it needs to be of
the same dimension as the ‘opening’ array.</p>
<p>The algorithm iterates over all grayscale values present in the array,
starting at the smallest value (black). For every grayscale value the array
is converted into a binary image where values larger than the grayscale
value become one (white) and all other values become zero (black). For each
of these binary images the minkowski functionals are computed according to
the function <a class="reference internal" href="#quantimpy.minkowski.functionals" title="quantimpy.minkowski.functionals"><code class="xref py py-func docutils literal notranslate"><span class="pre">functionals()</span></code></a>.</p>
<p>This function can be used in combination with the
<a class="reference internal" href="quantimpy.morphology.html#module-quantimpy.morphology" title="quantimpy.morphology"><code class="xref py py-func docutils literal notranslate"><span class="pre">morphology()</span></code></a> module to compute the Minkowski functions of
different morphological distance maps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opening</strong> (<em>ndarray</em><em>, </em><em>float</em>) – Opening can be either a 2D or 3D array of data type <cite>float</cite>.</p></li>
<li><p><strong>res</strong> (<em>ndarray</em><em>, </em><em>{int</em><em>, </em><em>float}</em><em>, </em><em>optional</em>) – By default the resolution is assumed to be 1 &lt;unit of length&gt;/pixel in all directions.
If a resolution is provided it needs to be of the same dimension as the
image array.</p></li>
<li><p><strong>norm</strong> (<em>bool</em><em>, </em><em>defaults to False</em>) – When norm=True the functions are normalized with the total area or
volume of the image. Defaults to norm=False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – In the case of a 2D image this function returns a tuple of Numpy arrays
consisting of the distance (assuming one grayscale value is used per
unit of length), area, length, and the Euler characteristic. In the
case of a 3D image this function returns a tuple of Numpy arrays
consistenting of the distance, volume, surface, curvature, and the Euler
characteristic. The return data type is <cite>float</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple, ndarray, float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#quantimpy.minkowski.functionals" title="quantimpy.minkowski.functionals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">functionals</span></code></a>, <a class="reference internal" href="#quantimpy.minkowski.functions_close" title="quantimpy.minkowski.functions_close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">functions_close</span></code></a>, <a class="reference internal" href="quantimpy.morphology.html#module-quantimpy.morphology" title="quantimpy.morphology"><code class="xref py py-obj docutils literal notranslate"><span class="pre">morphology</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>These examples use the Skimage Python package <a class="footnote-reference brackets" href="#id14" id="id8">4</a> and the Matplotlib Python
package <a class="footnote-reference brackets" href="#id15" id="id9">5</a>. For a 2D image the Minkowski functions can be computed using
the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="p">(</span><span class="n">disk</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">morphology</span> <span class="k">as</span> <span class="n">mp</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">minkowski</span> <span class="k">as</span> <span class="n">mk</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">image</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">,</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

<span class="n">erosion_map</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">erode_map</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">erosion_map</span><span class="p">[:,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">dist</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">euler</span> <span class="o">=</span> <span class="n">mk</span><span class="o">.</span><span class="n">functions_open</span><span class="p">(</span><span class="n">erosion_map</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">area</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">length</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">euler</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>For a 3D image the Minkowski functionals can be computed using the following
example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ball</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">morphology</span> <span class="k">as</span> <span class="n">mp</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">minkowski</span> <span class="k">as</span> <span class="n">mk</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">128</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">image</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">,</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">,</span><span class="mi">16</span><span class="p">:</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span> <span class="n">ball</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

<span class="n">erosion_map</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">erode_map</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[:,:,</span><span class="mi">64</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">erosion_map</span><span class="p">[:,:,</span><span class="mi">64</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">dist</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">curvature</span><span class="p">,</span> <span class="n">euler</span> <span class="o">=</span> <span class="n">mk</span><span class="o">.</span><span class="n">functions_open</span><span class="p">(</span><span class="n">erosion_map</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">volume</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">surface</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">curvature</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="n">euler</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Charles R. Harris, K. Jarrod Millman, Stéfan J. van der Walt et al.,
“Array programming with NumPy”, Nature, vol. 585, pp 357-362, 2020,
doi:<a class="reference external" href="https://doi.org/10.1038/s41586-020-2649-2">10.1038/s41586-020-2649-2</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Joachim Ohser and Frank Mücklich, “Statistical analysis of
microstructures in materials science”, Wiley and Sons, New York (2000) ISBN:
0471974862</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Klaus R. Mecke, “Additivity, convexity, and beyond: applications of
Minkowski Functionals in statistical physics” in “Statistical Physics
and Spatial Statistics”, pp 111–184, Springer (2000) doi:
<a class="reference external" href="https://doi.org/10.1007/3-540-45043-2_6">10.1007/3-540-45043-2_6</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id14"><span class="brackets">4</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id6">2</a>,<a href="#id8">3</a>)</span></dt>
<dd><p>Stéfan van der Walt, Johannes L. Schönberger, Juan Nunez-Iglesias,
François Boulogne, Joshua D. Warner, Neil Yager, Emmanuelle Gouillart,
Tony Yu and the scikit-image contributors. “scikit-image: Image
processing in Python.” PeerJ 2:e453 (2014) doi: <a class="reference external" href="https://doi.org/10.7717/peerj.453">10.7717/peerj.453</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id15"><span class="brackets">5</span><span class="fn-backref">(<a href="#id5">1</a>,<a href="#id7">2</a>,<a href="#id9">3</a>)</span></dt>
<dd><p>John D. Hunter, “Matplotlib: A 2D Graphics Environment”, Computing in
Science &amp; Engineering, vol. 9, no. 3, pp. 90-95, 2007.
doi:<a class="reference external" href="https://doi.org/10.1109/MCSE.2007.55">10.1109/MCSE.2007.55</a></p>
</dd>
</dl>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="quantimpy.brisque.html"
                          title="previous chapter">quantimpy.brisque module</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="quantimpy.morphology.html"
                          title="next chapter">quantimpy.morphology module</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/quantimpy.minkowski.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quantimpy.morphology.html" title="quantimpy.morphology module"
             >next</a> |</li>
        <li class="right" >
          <a href="quantimpy.brisque.html" title="quantimpy.brisque module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuantImPy 0.4.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="quantimpy.html" >quantimpy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quantimpy.minkowski module</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Arnout Boelens.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>