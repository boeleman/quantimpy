

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>quantimpy.segmentation module &#8212; QuantImPy 0.4.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bizstyle.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="quantimpy.morphology module" href="quantimpy.morphology.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quantimpy.morphology.html" title="quantimpy.morphology module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuantImPy 0.4.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="quantimpy.html" accesskey="U">quantimpy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quantimpy.segmentation module</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-quantimpy.segmentation">
<span id="quantimpy-segmentation-module"></span><h1>quantimpy.segmentation module<a class="headerlink" href="#module-quantimpy.segmentation" title="Permalink to this headline">¶</a></h1>
<p>Functions for image segmentation</p>
<p>This module contains various functions for the image segmentation of both 2D and 3D NumPy <a class="footnote-reference brackets" href="#id29" id="id1">1</a> arrays.</p>
<dl class="py function">
<dt class="sig sig-object py" id="quantimpy.segmentation.anisodiff">
<span class="sig-prename descclassname"><span class="pre">quantimpy.segmentation.</span></span><span class="sig-name descname"><span class="pre">anisodiff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">option</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quantimpy.segmentation.anisodiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Anisotropic diffusion filter</p>
<p>This function applies an anisotropic diffusion filter to the 2D or 3D NumPy
array <cite>image</cite>. This is also known as Perona Malik diffusion <a class="footnote-reference brackets" href="#id30" id="id2">2</a> and is an
edge preserving noise reduction method. The code is based on a Matlab code
by Perona, Shiota, and Malik <a class="footnote-reference brackets" href="#id32" id="id3">3</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>ndarray</em><em>, </em><em>{int</em><em>, </em><em>uint</em><em>, </em><em>float}</em>) – 2D or 3D grayscale input image.</p></li>
<li><p><strong>option</strong> (<em>int</em><em>, </em><em>defaults to 1</em>) – <p>The <cite>option</cite> parameter selects the conduction coefficient used by the
filter. <cite>option=0</cite> selects the following conduction coefficient:</p>
<div class="math notranslate nohighlight">
\[g (\nabla I) = \exp{(-\frac{||\nabla I||}{K})},\]</div>
<p>where <span class="math notranslate nohighlight">\(\nabla I\)</span> is the image brightness gradient, and <span class="math notranslate nohighlight">\(K\)</span>
is a constant. This equation is used in a Matlab code by Perona,
Shiota, and Malik <a class="footnote-reference brackets" href="#id32" id="id4">3</a>. <cite>option=1</cite> selects the conduction coefficient:</p>
<div class="math notranslate nohighlight">
\[g (\nabla I) = \exp{(-\left(\frac{||\nabla I||}{K}\right)^{2})},\]</div>
<p>and <cite>option=2</cite> selects the coefficient:</p>
<div class="math notranslate nohighlight">
\[g (\nabla I) = \frac{1}{1 + (\frac{||\nabla I||}{K})^{2}}.\]</div>
<p>Option one privileges high-contrast edges over low-contrast ones, while
option two privileges wide regions over smaller ones <a class="footnote-reference brackets" href="#id30" id="id5">2</a>.</p>
</p></li>
<li><p><strong>niter</strong> (<em>int</em><em>, </em><em>defaults to 1</em>) – The number of iterations that the filter is applied.</p></li>
<li><p><strong>K</strong> (<em>float</em><em>, </em><em>defaults to 50</em>) – The value of constant <span class="math notranslate nohighlight">\(K\)</span> in the above equations.</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>defaults to 0.1</em>) – Sets the diffusion “time” step size. When <span class="math notranslate nohighlight">\(\gamma \leq 0.25\)</span>,
stability is ensured.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Noise reduced 2D or 3D output image. The return data type is float and
the image is normalized betweeen 0 and 1 or -1 and 1.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, float</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This example uses the NumPy <a class="footnote-reference brackets" href="#id29" id="id6">1</a>, and Matplotlib Python packages <a class="footnote-reference brackets" href="#id33" id="id7">4</a>. The
NumPy data file “<a class="reference external" href="https://github.com/boeleman/quantimpy/raw/thresholding/test/rock_2d.npy">rock_2d.npy</a>” is available on Github <a class="footnote-reference brackets" href="#id39" id="id8">9</a> <a class="footnote-reference brackets" href="#id40" id="id9">10</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">segmentation</span> <span class="k">as</span> <span class="n">sg</span>

<span class="c1"># Load data</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;rock_2d.npy&quot;</span><span class="p">)</span>

<span class="c1"># Apply anisotropic diffusion filter</span>
<span class="n">diffusion</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">anisodiff</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Show results</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>  <span class="c1"># left side</span>
<span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>  <span class="c1"># right side</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">diffusion</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quantimpy.segmentation.bilevel">
<span class="sig-prename descclassname"><span class="pre">quantimpy.segmentation.</span></span><span class="sig-name descname"><span class="pre">bilevel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thres_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thres_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quantimpy.segmentation.bilevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute bi-level image segmentation</p>
<p>This function computes the bi-level binary segmentation of the 2D or 3D
NumPy array <cite>image</cite> <a class="footnote-reference brackets" href="#id36" id="id10">7</a>. First, an initial segmentation is computed using
the minimum threshold value <cite>thres_min</cite>. Then, iteratively, this initial
segmented image is dilated and all voxels that are below the maximum
threshold value <cite>thres_max</cite> are added to the segmented image. This continues
untill no more changes to the segmented image are observed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>ndarray</em><em>, </em><em>{int</em><em>, </em><em>uint</em><em>, </em><em>float}</em>) – 2D or 3D grayscale input image.</p></li>
<li><p><strong>thres_min</strong> (<em>float</em>) – Minimum threshold value for bi-level segmentation.</p></li>
<li><p><strong>thres_max</strong> (<em>float</em>) – Maximum threshold value for bi-level segmentation.</p></li>
<li><p><strong>debug</strong> (<em>bool</em><em>, </em><em>defaults to &quot;False&quot;</em>) – When this parameter is set to “True”, (cross sections of) all the
intermediate segmentation images are written to disk. The default is
“False”.</p></li>
<li><p><strong>debug_dir</strong> (<em>str</em><em>, </em><em>defaults to &quot;./&quot;</em>) – Sets the output directory for debugging images. Defaults to “./”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Returns either a 2D or 3D boolean ndarray of the segmented image.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#quantimpy.segmentation.gradient" title="quantimpy.segmentation.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>This example uses the NumPy <a class="footnote-reference brackets" href="#id29" id="id11">1</a>, and Matplotlib Python packages <a class="footnote-reference brackets" href="#id33" id="id12">4</a>. The
NumPy data file “<a class="reference external" href="https://github.com/boeleman/quantimpy/raw/thresholding/test/rock_3d.npy">rock_3d.npy</a>” is available on Github <a class="footnote-reference brackets" href="#id39" id="id13">9</a> <a class="footnote-reference brackets" href="#id40" id="id14">10</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">segmentation</span> <span class="k">as</span> <span class="n">sg</span>

<span class="c1"># Load data</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;rock_3d.npy&quot;</span><span class="p">)</span>

<span class="c1"># Apply anisotropic diffusion filter</span>
<span class="n">diffusion</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">anisodiff</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Compute minimum and maximum thresholds</span>
<span class="n">thrshld_min</span><span class="p">,</span> <span class="n">thrshld_max</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">diffusion</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

<span class="c1"># Apply bi-level segmentation</span>
<span class="n">binary</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bilevel</span><span class="p">(</span><span class="n">diffusion</span><span class="p">,</span> <span class="n">thrshld_min</span><span class="p">,</span> <span class="n">thrshld_max</span><span class="p">)</span>

<span class="c1"># Show results</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gray</span><span class="p">()</span>  <span class="c1"># show the result in grayscale</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">131</span><span class="p">)</span>
<span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">132</span><span class="p">)</span>
<span class="n">ax3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">133</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">50</span><span class="p">,:,:])</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">diffusion</span><span class="p">[</span><span class="mi">50</span><span class="p">,:,:])</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binary</span><span class="p">[</span><span class="mi">50</span><span class="p">,:,:])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quantimpy.segmentation.gradient">
<span class="sig-prename descclassname"><span class="pre">quantimpy.segmentation.</span></span><span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug_dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quantimpy.segmentation.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute thresholds for bi-level segmentation using gradient masks</p>
<p>This function computes the minimum and maximum threshold values for the 2D
or 3D NumPy array <cite>image</cite>  using gradient masks <a class="footnote-reference brackets" href="#id38" id="id15">8</a>. These threshold
values, in turn, can be used as inputs for the bi-level segmentation
function, <a class="reference internal" href="#quantimpy.segmentation.bilevel" title="quantimpy.segmentation.bilevel"><code class="xref py py-func docutils literal notranslate"><span class="pre">bilevel()</span></code></a>. The gradient masks are
computed using Sobel and Laplace edge detection filters combined with the
unimodal thresholding function, <a class="reference internal" href="#quantimpy.segmentation.unimodal" title="quantimpy.segmentation.unimodal"><code class="xref py py-func docutils literal notranslate"><span class="pre">unimodal()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>ndarray</em><em>, </em><em>{int</em><em>, </em><em>uint</em><em>, </em><em>float}</em>) – 2D or 3D grayscale input image.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>defaults to 1.25</em>) – <p>The parameter <span class="math notranslate nohighlight">\(\alpha &gt; 1\)</span> is used to compute the minimum
threshold value using the formula:</p>
<div class="math notranslate nohighlight">
\[T_{\text{min}} = x_{\text{mode}} - \alpha (x_{\text{mode}} -
T_{\text{max}}),\]</div>
<p>where <span class="math notranslate nohighlight">\(T_{\text{min}}\)</span> is the minimum threshold value,
<span class="math notranslate nohighlight">\(x_{\text{mode}}\)</span> is the mode of the histogram of <cite>image</cite>, and
<span class="math notranslate nohighlight">\(T_{\text{max}}\)</span> is the maximum threshold value. The less noise
<cite>image</cite> contains, the closer <span class="math notranslate nohighlight">\(\alpha\)</span> can be set to one.</p>
</p></li>
<li><p><strong>debug</strong> (<em>bool</em><em>, </em><em>defaults to &quot;False&quot;</em>) – When this parameter is set to “True”, filtered images, masks, and
histrograms are written to disk. The default is “False”.</p></li>
<li><p><strong>debug_dir</strong> (<em>str</em><em>, </em><em>defaults to &quot;./&quot;</em>) – Sets the output directory for debugging images. Defaults to “./”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Returns minimum and maximum threshold values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple, float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#quantimpy.segmentation.bilevel" title="quantimpy.segmentation.bilevel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bilevel</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>This example uses the NumPy package <a class="footnote-reference brackets" href="#id29" id="id16">1</a>. The NumPy data file “<a class="reference external" href="https://github.com/boeleman/quantimpy/raw/thresholding/test/rock_2d.npy">rock_2d.npy</a>” is available on Github <a class="footnote-reference brackets" href="#id39" id="id17">9</a> <a class="footnote-reference brackets" href="#id40" id="id18">10</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">segmentation</span> <span class="k">as</span> <span class="n">sg</span>

<span class="c1"># Load data</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;rock_2d.npy&quot;</span><span class="p">)</span>

<span class="c1"># Apply anisotropic diffusion filter</span>
<span class="n">diffusion</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">anisodiff</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Compute minimum and maximum thresholds</span>
<span class="n">thrshld_min</span><span class="p">,</span> <span class="n">thrshld_max</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">diffusion</span><span class="p">)</span>

<span class="c1"># Print results</span>
<span class="nb">print</span><span class="p">(</span><span class="n">thrshld_min</span><span class="p">,</span> <span class="n">thrshld_max</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quantimpy.segmentation.histogram">
<span class="sig-prename descclassname"><span class="pre">quantimpy.segmentation.</span></span><span class="sig-name descname"><span class="pre">histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quantimpy.segmentation.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an image histogram</p>
<p>This function creates an histogram for the 2D or 3D NumPy array <cite>image</cite>. The
histogram is 8-bit (<span class="math notranslate nohighlight">\(2^8\)</span> bins) by default. The function is coded
around the <cite>numpy.histogram</cite> function. However, this functions returns the
center locations of the bins instead of the edges. For <cite>float</cite> or 16-bit
images the bin size is scaled accordingly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>ndarray</em><em>, </em><em>{int</em><em>, </em><em>uint</em><em>, </em><em>float}</em>) – 2D or 3D grayscale input image.</p></li>
<li><p><strong>bits</strong> (<em>int</em><em>, </em><em>defaults to 8</em>) – <span class="math notranslate nohighlight">\(2^{\text{bits}}\)</span> bins are used for the histogram. Defaults to 8
bits or 256 bins.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Returns two ndarrays: one with the histogram and one with the bin
centers.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple, float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#quantimpy.segmentation.unimodal" title="quantimpy.segmentation.unimodal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unimodal</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>This example uses the NumPy <a class="footnote-reference brackets" href="#id29" id="id19">1</a>, and Matplotlib Python packages <a class="footnote-reference brackets" href="#id33" id="id20">4</a>. The
NumPy data file “<a class="reference external" href="https://github.com/boeleman/quantimpy/raw/thresholding/test/rock_3d.npy">rock_3d.npy</a>” is available on Github <a class="footnote-reference brackets" href="#id39" id="id21">9</a> <a class="footnote-reference brackets" href="#id40" id="id22">10</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">segmentation</span> <span class="k">as</span> <span class="n">sg</span>

<span class="c1"># Load data uint16</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;rock_3d.npy&quot;</span><span class="p">)</span>

<span class="c1"># Compute histpgram</span>
<span class="n">hist</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">width</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Plot histogram</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span><span class="n">hist</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="quantimpy.segmentation.unimodal">
<span class="sig-prename descclassname"><span class="pre">quantimpy.segmentation.</span></span><span class="sig-name descname"><span class="pre">unimodal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'right'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#quantimpy.segmentation.unimodal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute unimodal threshold</p>
<p>Using image histogram <cite>hist</cite>, this function computes the unimodal threshold
<a class="footnote-reference brackets" href="#id35" id="id23">6</a>. This algorithms is slightly modified modified from the original
method. Instead of defining the end of the distribution as the point where
the histogram is zero, this algorithm takes the point that contains 99.7% of
the observations. This is equivalent to three times the standard deviation
for a Gaussian distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hist</strong> (<em>ndarray</em><em>, </em><em>int</em>) – Histogram computed by the function <a class="reference internal" href="#quantimpy.segmentation.histogram" title="quantimpy.segmentation.histogram"><code class="xref py py-func docutils literal notranslate"><span class="pre">histogram()</span></code></a>.</p></li>
<li><p><strong>side</strong> (<em>string</em><em>, </em><em>defaults to &quot;right&quot;</em>) – Whether to compute the unimodal threshold on the left or right side of
the histogram maximum. Defaults to “right”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Index of the unimodal threshold value in input array <cite>hist</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#quantimpy.segmentation.histogram" title="quantimpy.segmentation.histogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">histogram</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>This example uses the NumPy <a class="footnote-reference brackets" href="#id29" id="id24">1</a>, Matplotlib <a class="footnote-reference brackets" href="#id33" id="id25">4</a>, and SciPy Python packages
<a class="footnote-reference brackets" href="#id34" id="id26">5</a>. NumPy data file “<a class="reference external" href="https://github.com/boeleman/quantimpy/raw/thresholding/test/rock_2d.npy">rock_2d.npy</a>” is available on Github <a class="footnote-reference brackets" href="#id39" id="id27">9</a> <a class="footnote-reference brackets" href="#id40" id="id28">10</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">quantimpy</span> <span class="kn">import</span> <span class="n">filters</span>

<span class="c1"># Load data</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;rock_2d.npy&quot;</span><span class="p">)</span>

<span class="c1"># Filter image</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">anisodiff</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Edge detection</span>
<span class="n">laplace</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">laplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="c1"># Compute histpgram</span>
<span class="n">hist</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">laplace</span><span class="p">)</span>
<span class="n">width</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Compute unimodal threshold</span>
<span class="n">thrshld</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">unimodal</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>

<span class="c1"># Plot histogram</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">thrshld</span><span class="p">],</span> <span class="n">hist</span><span class="p">[</span><span class="n">thrshld</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Compute unimodal threshold</span>
<span class="n">thrshld</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">unimodal</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

<span class="c1"># Plot histogram</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">thrshld</span><span class="p">],</span> <span class="n">hist</span><span class="p">[</span><span class="n">thrshld</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id29"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id6">2</a>,<a href="#id11">3</a>,<a href="#id16">4</a>,<a href="#id19">5</a>,<a href="#id24">6</a>)</span></dt>
<dd><p>Charles R. Harris, K. Jarrod Millman, Stéfan J. van der Walt et al.,
“Array programming with NumPy”, Nature, vol. 585, pp 357-362, 2020,
doi:<a class="reference external" href="https://doi.org/10.1038/s41586-020-2649-2">10.1038/s41586-020-2649-2</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id30"><span class="brackets">2</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p>Pietro Perona and Jitendra Malik, “Scale-space and edge detection
using anisotropic diffusion”, IEEE Transactions on pattern analysis and
machine intelligence, vol. 12, no. 7, pp 629-639, 1990, doi:<a class="reference external" href="https://doi.org/10.1109/34.56205">10.1109/34.56205</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id32"><span class="brackets">3</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id4">2</a>)</span></dt>
<dd><p>Pietro Perona, Takahiro Shiota, and Jitendra Malik, “Anisotropic
diffusion”, in “Geometry-driven diffusion in computer vision”, ed. Bart
M. ter Haar Romeny, pp 73-92, 1994, isbn: 9789401716994</p>
</dd>
<dt class="label" id="id33"><span class="brackets">4</span><span class="fn-backref">(<a href="#id7">1</a>,<a href="#id12">2</a>,<a href="#id20">3</a>,<a href="#id25">4</a>)</span></dt>
<dd><p>John D. Hunter, “Matplotlib: A 2D Graphics Environment”, Computing in
Science &amp; Engineering, vol. 9, no. 3, pp. 90-95, 2007.
doi:<a class="reference external" href="https://doi.org/10.1109/MCSE.2007.55">10.1109/MCSE.2007.55</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id34"><span class="brackets"><a class="fn-backref" href="#id26">5</a></span></dt>
<dd><p>Pauli Virtanen, Ralf Gommers, Travis E. Oliphant, et al., “SciPy
1.0: Fundamental Algorithms for Scientific Computing in Python”, Nature
Methods, vol. 17, pp 261-272, 2020, doi:<a class="reference external" href="https://doi.org/10.1038/s41592-019-0686-2">10.1038/s41592-019-0686-2</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id35"><span class="brackets"><a class="fn-backref" href="#id23">6</a></span></dt>
<dd><p>Paul Rosin, “Unimodal thresholding”, Pattern recognition, vol. 34,
no. 11, pp 2083-2096, 2001, doi:<a class="reference external" href="https://doi.org/10.1016/S0031-3203(00)00136-9">10.1016/S0031-3203(00)00136-9</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id36"><span class="brackets"><a class="fn-backref" href="#id10">7</a></span></dt>
<dd><p>Hans-Jörg Vogel and Andre Kretzschmar, “Topological characterization of
pore space in soil—sample preparation and digital image-processing”,
Geoderma, vol. 73, no. 1-2, pp 23–38, 1996, doi:<a class="reference external" href="https://doi.org/10.1016/0016-7061(96)00043-2">10.1016/0016-7061(96)00043-2</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id38"><span class="brackets"><a class="fn-backref" href="#id15">8</a></span></dt>
<dd><p>Steffen Schlüter, Ulrich Weller, and Hans-Jörg Vogel, “Segmentation
of X-ray microtomography images of soil using gradient masks”, Computers
&amp; Geosciences, vol. 36, no. 10, pp 1246–1251, 2010, doi:<a class="reference external" href="https://doi.org/10.1016/j.cageo.2010.02.007">10.1016/j.cageo.2010.02.007</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id39"><span class="brackets">9</span><span class="fn-backref">(<a href="#id8">1</a>,<a href="#id13">2</a>,<a href="#id17">3</a>,<a href="#id21">4</a>,<a href="#id27">5</a>)</span></dt>
<dd><p>Catherine Spurin, Tom Bultreys, Maja Rücker, et al., “The
development of intermittent multiphase fluid flow pathways through a
porous rock”, Advances in Water Resources, vol. 150, 2021,
doi:<a class="reference external" href="https://doi.org/10.1016/j.advwatres.2021.103868">10.1016/j.advwatres.2021.103868</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id40"><span class="brackets">10</span><span class="fn-backref">(<a href="#id9">1</a>,<a href="#id14">2</a>,<a href="#id18">3</a>,<a href="#id22">4</a>,<a href="#id28">5</a>)</span></dt>
<dd><p>Catherine Spurin, Tom Bultreys, Maja Rücker, et al., “Real-Time
Imaging Reveals Distinct Pore-Scale Dynamics During Transient and
Equilibrium Subsurface Multiphase Flow”, Water Resources Research, vol.
56, no. 12, 2020, doi:<a class="reference external" href="https://doi.org/10.1029/2020WR028287">10.1029/2020WR028287</a></p>
</dd>
</dl>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="quantimpy.morphology.html"
                          title="previous chapter">quantimpy.morphology module</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/quantimpy.segmentation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quantimpy.morphology.html" title="quantimpy.morphology module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuantImPy 0.4.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="quantimpy.html" >quantimpy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quantimpy.segmentation module</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Arnout Boelens.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>